$date
	Fri Mar 21 13:08:28 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module min_mex_tb $end
$var wire 1 ! outValid $end
$var wire 5 " data_out [4:0] $end
$var parameter 32 # ADDR_WIDTH $end
$var parameter 32 $ DATA_WIDTH $end
$var reg 4 % addr [3:0] $end
$var reg 1 & clk $end
$var reg 5 ' data [4:0] $end
$var reg 1 ( dataValid $end
$var reg 1 ) read $end
$var reg 1 * reset $end
$scope module dut $end
$var wire 4 + addr [3:0] $end
$var wire 1 & clk $end
$var wire 5 , data [4:0] $end
$var wire 1 ( dataValid $end
$var wire 1 ) read $end
$var wire 1 * reset $end
$var wire 3 - state [2:0] $end
$var wire 1 . resetComplete $end
$var wire 1 ! outValid $end
$var wire 1 / dp_done $end
$var wire 4 0 data_out [3:0] $end
$var parameter 32 1 ADDR_WIDTH $end
$var parameter 32 2 DATA_WIDTH $end
$scope module control_unit $end
$var wire 1 & clk $end
$var wire 1 ( dataValid $end
$var wire 1 ) read $end
$var wire 1 * reset $end
$var wire 1 . resetComplete $end
$var wire 1 ! outValid $end
$var wire 1 / dp_done $end
$var parameter 32 3 ADDR_WIDTH $end
$var parameter 32 4 DATA_WIDTH $end
$var parameter 3 5 S_DONE $end
$var parameter 3 6 S_IDLE $end
$var parameter 3 7 S_READ $end
$var parameter 3 8 S_READ_INTERMEDIATE_1 $end
$var parameter 3 9 S_READ_INTERMEDIATE_2 $end
$var parameter 3 : S_RUN $end
$var parameter 36 ; depth $end
$var reg 3 < nxt_state [2:0] $end
$var reg 3 = state [2:0] $end
$upscope $end
$scope module datapath_unit $end
$var wire 4 > addr [3:0] $end
$var wire 1 & clk $end
$var wire 5 ? data_in [4:0] $end
$var wire 5 @ mem_data [4:0] $end
$var wire 1 * reset $end
$var wire 3 A state [2:0] $end
$var wire 5 B data_out [4:0] $end
$var parameter 32 C ADDR_WIDTH $end
$var parameter 32 D DATA_WIDTH $end
$var parameter 3 E S_DONE $end
$var parameter 3 F S_IDLE $end
$var parameter 3 G S_READ $end
$var parameter 3 H S_READ_INTERMEDIATE_1 $end
$var parameter 3 I S_READ_INTERMEDIATE_2 $end
$var parameter 3 J S_RUN $end
$var parameter 36 K depth $end
$var reg 1 / dp_done $end
$var reg 1 L re $end
$var reg 5 M resetAddr [4:0] $end
$var reg 1 . resetComplete $end
$var reg 1 N resetting $end
$var reg 1 O we $end
$scope module m $end
$var wire 4 P addr [3:0] $end
$var wire 1 & clk $end
$var wire 5 Q data [4:0] $end
$var wire 1 L readEnable $end
$var wire 1 O writeEnable $end
$var parameter 32 R ADDR_WIDTH $end
$var parameter 32 S DATA_WIDTH $end
$var reg 5 T temp_data [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b101 S
b100 R
b10000 K
b100 J
b11 I
b10 H
b1 G
b0 F
b101 E
b101 D
b100 C
b10000 ;
b100 :
b11 9
b10 8
b1 7
b0 6
b101 5
b101 4
b100 3
b101 2
b100 1
b101 $
b100 #
$end
#0
$dumpvars
bx T
bx Q
b0 P
xO
xN
bx M
xL
bx B
bx A
bx @
b0 ?
b0 >
bx =
b0 <
bx 0
x/
1.
bx -
b0 ,
b0 +
0*
0)
0(
b0 '
0&
b0 %
b0xxxx "
x!
$end
#5000
0!
b1 <
b0 -
b0 =
b0 A
1&
#10000
0&
#15000
b1 -
b1 =
b1 A
b0zzzz "
bz 0
b0 @
b0 Q
bz B
1O
0L
1&
#20000
b10101 @
b10101 Q
b10 <
0&
b10101 '
b10101 ,
b10101 ?
b10 %
b10 +
b10 >
b10 P
1)
1(
#25000
b11 <
b10 -
b10 =
b10 A
1&
#30000
0&
0)
0(
#35000
b100 <
b11 -
b11 =
b11 A
1&
#40000
0&
#45000
b100 -
b100 =
b100 A
1&
#50000
0&
#55000
b0xxxx "
bx 0
bx @
bx Q
bx B
b101 <
1/
0O
1L
1&
#60000
0&
#65000
b101 "
b101 0
1!
b10101 B
b10101 @
b10101 Q
b101 -
b101 =
b101 A
b10101 T
1&
#70000
0&
#75000
1&
#80000
0&
#85000
1&
#90000
0&
